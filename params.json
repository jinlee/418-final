{"name":"Javascript Parallelization","tagline":"15-418 Final Project","body":"#418-final\r\n\r\nThis is the final project for 15-418. We'll be exploring ways to make javascript parallel.\r\n\r\nWe'll be doing this by using web workers and hacking on Mozilla's Spidermonkey.\r\n\r\n###Get the code from Mozilla\r\n\r\nFirst get the correct build from Mozilla:\r\n\r\n```\r\nhg clone -r 177109 http://hg.mozilla.org/mozilla-central mozilla-central\r\n```\r\n\r\nNote that to avoid errors, it's best to clone revision `177109`. This is the revision that we worked with. Also this part may take a while... There's a lot of code!\r\n\r\nNow you can clone this repo, and put the js/ folder into the top level directory that you just created.\r\n\r\n###Get the code from this repo\r\n\r\nThere are two options here. The hack-ish way is to simply git clone this directory, which gives you the 418-final/ folder. Inside is the js/ folder that needs to be stuck into mozilla-central for the build to work.\r\n\r\nSo you can do this by copying the contents of 418-final/* (including .git and .gitignore) into mozilla-central/\r\n\r\n\r\nThe second option is to do the following\r\n\r\n```\r\ncd mozilla-central\r\nmv js js_backup\r\ngit init\r\ngit remote add origin https://github.com/jinslee/418-final.git\r\ngit pull origin master\r\n```\r\n\r\nNow you should be ready to build!\r\n\r\n###Building\r\n\r\nBuilding the js shell\r\n\r\n```\r\ncd mozilla-central/js/src\r\nautoconf213 # or autoconf2.13 or autoconf-2.13\r\nmkdir build_DBG.OBJ \r\ncd build_DBG.OBJ \r\n../configure --enable-debug --disable-optimize\r\nmake\r\n```\r\n\r\nNow the shell should be located at `mozilla-central/js/src/build_DBG.OBJ/js/src/js`\r\n\r\nRun it using `./js -i`\r\n\r\n\r\n###Examples\r\n\r\nHere are some examples to get you started.\r\n```javascript\r\nvar foo = function (n) {\r\n  return n * n;\r\n}\r\n\r\nvar seq = new Seq([0, 1, 2, 3]);\r\nseq.map(foo); // returns [0, 1, 4, 9]\r\n```\r\n\r\nYou can also pass in an callback function to be run after the map has finished.\r\n```javascript\r\nvar done = function(res) {\r\n  console.log(res);\r\n}\r\nseq.map(foo, done);\r\n```\r\n\r\nYou can chain multiple calls to map.\r\n```javascript\r\nseq.map(foo);\r\nseq.map(foo, done);\r\n// is the same as\r\nseq.map(foo).map(foo, done);\r\n```\r\n\r\nYou can pass in an auxiliary data structure using `require`. Be warned though, because of how web workers are designed (they don't share the address space), what you pass into `require` need to be explicitly copied to each worker.\r\n```javascript\r\nvar seq = new Seq([3, 2, 1, 0]);\r\nvar aux = [10, 20, 30, 40];\r\nseq.require({ name: 'aux', data: aux});\r\n// the map function now has access to the 'aux' variable\r\nseq.map(function (index) { return aux[index]; },\r\n        function (res) { console.log(res); });\r\n// returns the reverse of aux, [40, 30, 20, 10]\r\n```\r\n\r\nHere's a non-trivial example using `filter`.\r\n```javascript\r\nvar primes = new Seq(_.range(1000)); // _.range(n) returns [0, ..., n - 1]\r\n\r\n// a simple prime checker\r\nvar isPrime = function (n) {\r\n  if (n === 0 || n === 1) {\r\n    return false;\r\n  }\r\n  for (var i = 2; i < n; i++) {\r\n    if (n % i === 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nprimes.filter(isPrime, function (res) { console.log(res); }); // returns only primes!\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}